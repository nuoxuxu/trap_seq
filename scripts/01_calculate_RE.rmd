---
title: "DESeq calculation of RE and shifts in RE"
output:
  html_notebook:
    toc: true
    number_sections: true
    theme: readable
author: Nuo Xu
---
# Preprocessing

## Loading libraries

```{r load-libraries}
library(tximport)
library(GenomicFeatures)
library(magrittr)
library(ggplot2)
library(scales)
library(dplyr)
library(tidyr)
library(DESeq2)
library(stringr)
library(ggrepel)
library(SingleCellExperiment)
```

## Get gene count matrix from salmon output

### Nuo
```{r}
txdb <- makeTxDbFromGFF("/scratch/s/shreejoy/nxu/Genomic_references/hg38/Raw/Homo_sapiens.GRCh38.111.gtf")
k <- keys(txdb, keytype = "TXNAME")
tx2gene <- AnnotationDbi::select(txdb, k, "GENEID", "TXNAME")
tx2gene <- bind_rows(tx2gene, data.frame(TXNAME = c("eGFP"), GENEID = c("eGFP")))
files <- file.path(here("salmon/salmon_results"), list.files(here("salmon/salmon_results")), "quant.sf")
names(files) <- gsub("_quant", "", list.files(here("salmon/salmon_results")))
txi <- tximport(files, type = "salmon", tx2gene = tx2gene, ignoreTxVersion = TRUE, )
```

### Wendy
```{r}
txdb <- makeTxDbFromGFF("/scratch/s/shreejoy/nxu/Genomic_references/hg38/Raw/Homo_sapiens.GRCh38.104.gtf")
k <- keys(txdb, keytype = "TXNAME")
tx2gene <- AnnotationDbi::select(txdb, k, "GENEID", "TXNAME")
tx2gene <- bind_rows(tx2gene, data.frame(TXNAME = c("EGFP"), GENEID = c("EGFP")))
files <- list.files("salmon_with_eGFP/compiled_quants_egfp", full.names = TRUE)
names(files) <- stringr::str_extract(files, "(?<=/)[^/]+(?=_S)")
txi <- tximport(files, type = "salmon", tx2gene = tx2gene, ignoreTxVersion = TRUE)
```

## Obtain gene symbols
```{r}
# Obtain gene symbols
gtf_path <- "/scratch/s/shreejoy/nxu/Genomic_references/hg38/Raw/Homo_sapiens.GRCh38.111.gtf"
annotation_from_gtf <- rtracklayer::import(gtf_path) %>%
    dplyr::as_tibble() %>%
    dplyr::filter(type == "gene") %>%
    dplyr::select(gene_id, gene_name, gene_biotype)
```

# Calculate RE and shifts in RE

## Create DESeqDataSet

```{r deseqdataset}
# filter out lowly expressed genes
filtered_count_matrix <- txi$counts[rowSums(txi$counts) != 0, ]
sum(rowSums(filtered_count_matrix) < 20) / (dim(filtered_count_matrix)[1])
filtered_count_matrix <- filtered_count_matrix[rowSums(filtered_count_matrix) >= 20, ]

samples <- names(files)
assay <- str_extract(files, "IP|Input")
condition <- ifelse(grepl("_", samples), "PTEN_KO", "WT")
coldata <- data.frame(samples = samples, assay = assay, condition = condition)
dds <- DESeqDataSetFromTximport(txi, coldata, design = ~ samples)
dds <- DESeq2::estimateSizeFactors(dds)
saveRDS(dds, "proc/dds.rds")
```

## First method

### Calculate RE
```{r}
up_vec <- counts(dds, normalized=TRUE)[, colData(dds)$assay == "IP"]
down_vec <- counts(dds, normalized=TRUE)[, colData(dds)$assay == "Input"]
RE <- up_vec / down_vec

# RE <- RE[complete.cases(RE) & apply(RE, 1, function(x) all(is.finite(x))), ]
RE_quant_normalized <- preprocessCore::normalize.quantiles(RE, keep.names=TRUE)
```

### Calculate shifts in RE (log fold change and Z scores)
```{r}
RE_KO <- RE[, str_count(colnames(RE), "_") == 3]
RE_WT <- RE[, str_count(colnames(RE), "_") == 2]

log2_RE_FC <- log(rowMeans(RE_KO, na.rm = TRUE) / rowMeans(RE_WT, na.rm = TRUE), 2)
Z_score <- rowMeans(RE_KO, na.rm = TRUE) - rowMeans(RE_WT, na.rm = TRUE) / sqrt(apply(RE_KO, 1, sd, na.rm = TRUE)**2 + apply(RE_WT, 1, sd, na.rm = TRUE)**2)
```

### Write results
```{r}
results <- data.frame(gene_id = names(log2_RE_FC), log2_RE_FC = log2_RE_FC, Z_score = Z_score)

# add gene symbols to the data frame
results <- results %>%
    mutate(gene_id = rownames(results)) %>%
    left_join(annotation_from_gtf, join_by(gene_id))
# Selecting genes with significant shifts in RE. This is the same filtering threshold as in Rodriguez et al.
results <- results %>%
    filter_if(is.numeric, all_vars(!is.na(.) & !is.infinite(.))) %>%
    filter(abs(Z_score) > 2 & abs(log2_RE_FC) > 0.2) %>%
    arrange(desc(Z_score))

write.csv(results, "results/results.csv")
```

# Reproducing figures from Rodriguez et al.

## Figure 1D

Get TPM from txi object
```{r}
tpm <- txi$abundance
IP_mtx <- tpm[, which(grepl("IP", colnames(tpm)))] %>% log10()
IP_mtx <- data.frame(KO = rowMeans(IP_mtx[, c(1, 2, 6)]), WT = rowMeans(IP_mtx[, c(3, 4, 5)]))
Input_mtx <- tpm[, which(grepl("Input", colnames(tpm)))]  %>% log10()
Input_mtx <- data.frame(KO = rowMeans(Input_mtx[, c(1, 2, 6)]), WT = rowMeans(Input_mtx[, c(3, 4, 5)]))
```

Filter out genes with low TPM
```{r}
index_to_keep <- (rowSums(Input_mtx) > -2) & (rowSums(IP_mtx) > -2)
Input_mtx <- Input_mtx[index_to_keep, ]
IP_mtx <- IP_mtx[index_to_keep, ]
```

Pivot count matrices
```{r}
Input_mtx <- Input_mtx %>%
    mutate(gene = rownames(.)) %>%
    pivot_longer(cols = -gene, names_to = "condition", values_to = "Input")
IP_mtx <- IP_mtx %>%
    mutate(gene = rownames(.)) %>%
    pivot_longer(cols = -gene, names_to = "condition", values_to = "IP")
combined <- merge(Input_mtx, IP_mtx, by = c("gene", "condition"))
```

Plotting Figure 1D
```{r}
combined %>% ggplot(aes(x = Input, y = IP)) +
    geom_point(alpha = 0.5) +
    geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
    facet_grid(cols = vars(condition)) +
    xlab("Input RNA-seq (log10 TPM)") +
    ylab("IP RNA-seq (log10 TPM)")
ggsave("results/figures/Figure_1D.png")
```   

## Plotting distribution of eGFP counts in IP vs input samples

```{r}
TPM <- txi$abundance
eGFP <- TPM["eGFP", ]
df <- data.frame(TPM = unname(eGFP), sample = str_extract(names(eGFP), "IP|Input") %>% unlist())
ggplot(df, aes(x = sample, y = TPM)) +
    geom_boxplot() +
    geom_jitter(width=0.2, alpha=0.5)
ggsave("results/figures/RE_distribution.png")
```

## Figure 1H
```{r}
data.frame(KO = rowMeans(RE[, str_count(colnames(RE), "_") == 3]), WT = rowMeans(RE[, str_count(colnames(RE), "_") == 2])) %>% 
    # mutate(across(.cols = where(is.numeric), .fns = ~log10(. + 1))) %>%
    ggplot(aes(x = WT, y = KO)) +
        geom_point(alpha = 0.5) +
        geom_density2d() +
        geom_abline(intercept = 0, slope = 1) +
        scale_x_continuous(limits = c(0, 5)) +
        scale_y_continuous(limits = c(0, 5)) +
        xlab("Mean RE WT") +
        ylab("Mean RE KO")
ggsave("results/figures/Figure_1H.png", width = 5, height = 5)
```    

## Figure 2A
```{r}



```













# Comparing results

## Compare distribution
```{r boxplot}
RE %>%
    as.data.frame() %>%
    pivot_longer(cols = everything(), names_to = "sample", values_to = "RE") %>% 
    mutate(sample = factor(sample, levels = c("4_7_IP_S4", "4_9_IP_S5", "95_3_IP_S6", "87_IP_S1", "90_IP_S2", "91_IP_S3"))) %>% 
    mutate(condition = ifelse(str_count(sample, "_") == 3, "KO", "WT")) %>%
    mutate(across(.cols = where(is.numeric), .fns = ~log10(. + 1))) %>%
        ggplot(aes(x = sample, y = RE, color = condition)) +
            geom_boxplot(outliers = FALSE) +
            scale_y_continuous(limits = c(0, 0.75))
ggsave("results/figures/RE_distribution_OW.png", width = 5, height = 5)

RE.deseq.horizontal <- readRDS("/scratch/s/shreejoy/nxu/translatome-neurodevo/proc/RE_Rodriguez2020.rds")
RE.deseq.horizontal %>%
    select(-gene) %>% 
    pivot_longer(cols = everything(), names_to = "sample", values_to = "RE") %>%
    mutate(condition = ifelse(str_detect(sample, "37"), "KO", "WT")) %>%
    mutate(across(.cols = where(is.numeric), .fns = ~log10(. + 1))) %>%
        ggplot(aes(x = sample, y = RE, color = condition)) +
            geom_boxplot(outliers = FALSE) +
            scale_y_continuous(limits = c(0, 0.75))
ggsave("results/figures/RE_distribution_Rodriguez2020.png", width = 10, height = 5)
```

```{r}
res2 <- read.csv("results/results_RE_240408.csv")
res1 <- read.csv("results/results.csv")

dim(res1)
dim(res2)

length((intersect(res1$gene_name, res2$gene_name)))
```

There are two methods for calculating log2 fold change in RE. The first method is described in Rodriguez et al. 2020, 
which involves calculating RE for each replicate, using normalized counts obtained from DESeq2, then quantile normalize
the resulting ratios. Finally the ratios for all replicates are averaged to get the final RE for that condition.
RE fold change is the ratio of RE in WT vs PTEN_KO. The second method is to use the DESeq2 design matrix. Both methods involve
creating a DEXSeqDataSet object.